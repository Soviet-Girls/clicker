import time
import asyncio
import random

from vkbottle import GroupEventType
from vkbottle.bot import Message, MessageEvent

import data
import keyboard

from rules import CommandRule, WalletRule
from bot import bot

refresh_message = {}

@bot.on.message(CommandRule(["–Ω–∞—á–∞—Ç—å", "start", "—Å—Ç–∞—Ä—Ç"]))
async def start_message(message: Message):
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –±–æ—Ç –¥–ª—è –¥–æ–±—ã—á–∏ Soviet Girls Ruble. –î–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã –Ω–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É üéÆ –ò–≥—Ä–∞—Ç—å",
        keyboard=keyboard.get_main_keyboard( )
        )
    if message.ref:
        ref = int(message.ref)
        if ref != message.from_id:
            old_ref = await data.get_ref(message.from_id)
            if old_ref != 0:
                return
            await data.set_ref(message.from_id, ref)
            await data.change_ref_count(ref, 1)
            await data.change_score(ref, 1000)
            bot_message = "üéâ –í—ã –ø–æ–ª—É—á–∏–ª–∏ 1000 SG‚ÇΩ –∑–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥—Ä—É–≥–∞!"
            await bot.api.messages.send(
                user_id=ref,
                message=bot_message,
                random_id=random.randint(0, 2 ** 64)
            )

@bot.on.message(CommandRule(["/ref"]))
async def ref_admin_message(message: Message):
    ref = message.ref
    ref_source = message.ref_source
    await message.answer(f"ref: {ref}, ref_source: {ref_source}")
    
async def generate_play_message(user_id: int) -> str:
    score = await data.get_score(user_id)
    score = "{:,}".format(score).replace(",", " ")
    bot_message = f"üí∞ –¢–≤–æ–π —Å—á—ë—Ç: {score} SG‚ÇΩ"
    bot_message += "\n\n‚åõ –î–æ–±—ã—á–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É."
    wallet = await data.get_wallet(user_id)
    if wallet == "":
        bot_message += "\n\n‚ö†Ô∏è –ö–æ—à–µ–ª–µ–∫ Polygon –Ω–µ —É–∫–∞–∑–∞–Ω! –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –±–æ—Ç—É, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å SG‚ÇΩ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –∏–≥—Ä—ã."
    else:
        wallet = wallet[:5] + "..." + wallet[-5:]
        bot_message += f"\n\nüì¶ –í–∞—à –∫–æ—à–µ–ª–µ–∫: {wallet}.\n –ü–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –∏–≥—Ä—ã SG‚ÇΩ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ —ç—Ç–æ—Ç –∞–¥—Ä–µ—Å."
    return bot_message
    
# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã "üéÆ –ò–≥—Ä–∞—Ç—å"
async def play_message(event: MessageEvent):
    bot_message = await generate_play_message(event.object.peer_id)
    await bot.api.messages.send(
        user_id=event.object.peer_id,
        message=bot_message,
        keyboard=keyboard.get_play_keyboard(),
        random_id=random.randint(0, 2 ** 64)
    )
    await event.show_snackbar("üéÆ –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã "üõçÔ∏è  –£–ª—É—á—à–µ–Ω–∏—è"
async def upgrades_message(event: MessageEvent):
    user_id = event.object.peer_id
    bot_message = "–í—ã–±–µ—Ä–∏ —É–ª—É—á—à–µ–Ω–∏–µ:"
    await bot.api.messages.send(
        user_id=user_id,
        message=bot_message,
        keyboard=await keyboard.get_upgrades_keyboard(user_id),
        random_id=random.randint(0, 2 ** 64)
    )
    await event.show_snackbar("üõçÔ∏è –£–ª—É—á—à–µ–Ω–∏—è")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã "üîº –£–ª—É—á—à–µ–Ω–∏–µ –∫–ª–∏–∫–∞"
async def upgrade_cpc_message(event: MessageEvent):
    user_id = event.object.peer_id
    level = await data.get_level(user_id)
    price, income = data.price_count(level)
    score = await data.get_score(user_id)
    if score < price:
        await event.show_snackbar("üõë –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!")
        return
    try:
        await data.change_score(user_id, -price)
    except Exception as e:
        await event.show_snackbar("üõë –°–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ!")
        raise e
    _i = 0
    while True:
        try:
            await data.change_cpc(user_id, income)
            break
        except Exception as e:
            _i += 1
            if _i > 5:
                raise e
            await asyncio.sleep(1)
    _i = 0
    while True:
        try:
            await data.upgrade_level(user_id)
            break
        except Exception as e:
            _i += 1
            if _i > 5:
                raise e
            await asyncio.sleep(1)
    await event.show_snackbar("üîº –£–ª—É—á—à–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–æ!")
    await upgrades_message(event)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã "ü§ñ –ê–≤—Ç–æ–¥–æ–±—ã—á–∞"
async def upgrade_automine_message(event: MessageEvent):
    user_id = event.object.peer_id
    score = await data.get_score(user_id)
    if score < 5000:
        await event.show_snackbar("üõë –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!")
        return
    try:
        await data.change_score(user_id, -5000)
    except Exception as e:
        await event.show_snackbar("üõë –°–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ!")
        raise e
    _i = 0
    while True:
        try:
            await data.automine_on(user_id)
            break
        except Exception as e:
            _i += 1
            if _i > 5:
                raise e
            await asyncio.sleep(1)
    await event.show_snackbar("ü§ñ –ê–≤—Ç–æ–¥–æ–±—ã—á–∞ –≤–∫–ª—é—á–µ–Ω–∞!")
    await upgrades_message(event)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã "ü™ô –î–û–ë–´–¢–¨!"
async def mine_message(event: MessageEvent):
    user_id = event.object.peer_id
    cpc = await data.get_cpc(user_id)
    try:
        tm = int(time.time())
        automine_status = await data.get_automine_status(user_id)
        if automine_status:
            tm_last = await data.get_last_mine(user_id)
            tm_diff = tm - tm_last
            new_cpc = int(tm_diff /2 * cpc / 100)
            if new_cpc > 10000:
                new_cpc = 10000
            elif new_cpc < 1:
                new_cpc = 1
            cpc += new_cpc
        # await asyncio.sleep(6)
        await data.change_score(user_id, cpc)
        await data.set_last_mine(user_id, tm)
    except Exception as e:
        await event.show_snackbar("üõë –°–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ!")
        raise e
    score = await data.get_score(user_id)
    _rm = refresh_message.get(user_id, 0)
    try:
        await event.show_snackbar(f"ü™ô {score} (+{cpc})")
    except Exception as e:
        print(f"Error showing snackbar: {e}")
        await asyncio.sleep(4)
        await event.show_snackbar(f"ü™ô {score} (+{cpc})")
    try:
        if _rm == 4:
            bot_message = await generate_play_message(event.object.peer_id)
            await bot.api.messages.edit(
                peer_id=event.object.peer_id,
                conversation_message_id=event.conversation_message_id,
                message=bot_message,
                keyboard=keyboard.get_play_keyboard(),
                random_id=random.randint(0, 2 ** 64)
            )
            _rm = 0
        else:
            _rm += 1
        refresh_message[user_id] = _rm

    except Exception as e:
        print(f"Error editing message: {e}")


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã "üë• –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å"
async def ref_message(event: MessageEvent):
    user_id = event.object.peer_id
    count = await data.get_ref_count(user_id)
    link = f"https://vk.me/soviet_clicker?ref={user_id}"
    bot_message = "üë• –û—Ç–ø—Ä–∞–≤—å –ø—Ä–∏–≥–ª–∞—Å–∏—Ç–µ–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É –¥—Ä—É–∑—å—è–º, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å 1000 SG‚ÇΩ –∑–∞ –∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞!\n\n"
    bot_message += "–¢–∞–∫–∂–µ —Ç—ã –±—É–¥–µ—à—å –ø–æ—É–ª—á–∞—Ç—å –±–æ–Ω—É—Å–Ω—ã–π 1% –æ—Ç –¥–æ–±—ã—á–∏ —Ç–≤–æ–∏—Ö –¥—Ä—É–∑–µ–π (–æ–Ω –Ω–µ –±—É–¥–µ—Ç –æ—Ç–Ω–∏–º–∞—Ç—å—Å—è —É –¥—Ä—É–∑–µ–π).\n\n"
    bot_message += f"üßÆ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –¥—Ä—É–∑–µ–π: {count}\n\n"
    bot_message += f"üîó {link}"
    await bot.api.messages.send(
        user_id=user_id,
        message=bot_message,
        random_id=random.randint(0, 2 ** 64)
    )
    
    
# –û–±—Ä–∞–±–æ—Ç–∫–∞ callback
@bot.on.raw_event(GroupEventType.MESSAGE_EVENT, dataclass=MessageEvent)
async def callback_handler(event: MessageEvent):
    if event.object.payload.get("command") == "play":
        await play_message(event)
    elif event.object.payload.get("command") == "mine":
        await mine_message(event)
    elif event.object.payload.get("command") == "upgrades":
        await upgrades_message(event)
    elif event.object.payload.get("command") == "upgrade_cpc":
        await upgrade_cpc_message(event)
    elif event.object.payload.get("command") == "upgrade_automine":
        await upgrade_automine_message(event)
    elif event.object.payload.get("command") == "ref":
        await ref_message(event)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø—É
@bot.on.raw_event(GroupEventType.GROUP_JOIN)
async def group_join_handler(event):
    # –î–∞—ë–º –±–æ–Ω—É—Å –∑–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É
    user_id = event['object']['user_id']
    bonus = await data.get_invite_bonus(user_id)
    if bonus is False:
        await data.change_score(user_id, 1000)
        await data.set_invite_bonus(user_id, True)
        try:
            await bot.api.messages.send(
                user_id=user_id,
                message="üéâ –í—ã –ø–æ–ª—É—á–∏–ª–∏ 1000 SG‚ÇΩ –∑–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É!",
                random_id=random.randint(0, 2 ** 64)
            )
        except Exception as e:
            pass

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã—Ö–æ–¥–∞ –∏–∑ –≥—Ä—É–ø–ø—ã
@bot.on.raw_event(GroupEventType.GROUP_LEAVE)
async def group_leave_handler(event):
    user_id = event['object']['user_id']
    bonus = await data.get_invite_bonus(user_id)
    if bonus is True:
        await data.set_invite_bonus(user_id, False)
        await data.change_score(user_id, -1000)
    try:
        await bot.api.messages.send(
            user_id=user_id,
            message="üò¢ –í—ã –ø–æ—Ç–µ—Ä—è–ª–∏ –±–æ–Ω—É—Å–Ω—ã–µ 1000 SG‚ÇΩ –∑–∞ –≤—ã—Ö–æ–¥ –∏–∑ –≥—Ä—É–ø–ø—ã!",
            random_id=random.randint(0, 2 ** 64)
        )
    except Exception as e:
        pass


@bot.on.message(WalletRule())
async def wallet_message(message: Message):
    await data.set_wallet(message.from_id, message.text)
    await message.answer("üì¶ –ö–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")


@bot.on.message(text='/save')
async def save_message(message: Message):
    if message.from_id != 434356505:
        return
    await data.save_scores()
    await data.save_last_mines()
    await message.answer("üì¶ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!")

@bot.on.message(CommandRule(["/bonus"]))
async def bonus_message(message: Message):
    target_id = int(message.text.split()[1])
    bonus = int(message.text.split()[2])
    await data.change_score(target_id, bonus)
    await message.answer(f"üéâ –í—ã–¥–∞–Ω–æ {bonus} SG‚ÇΩ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {target_id}")


@bot.loop_wrapper.interval(minutes=5)
async def save_scores():
    await data.save_scores()
    await data.save_last_mines()

bot.run_forever()